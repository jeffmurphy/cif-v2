package CIF::Archive::Plugin::Malware;
use base 'CIF::Archive::Plugin';

use strict;
use warnings;

use Module::Pluggable require => 1, search_path => [__PACKAGE__];

__PACKAGE__->table('malware');
__PACKAGE__->columns(Primary => 'id');
__PACKAGE__->columns(All => qw/id uuid guid hash confidence reporttime created/);
__PACKAGE__->sequence('malware_id_seq');

use Iodef::Pb::Simple qw(:all);

my @plugins = __PACKAGE__->plugins();

sub query { } # handled by the address module

sub insert {
    my $class = shift;
    my $data = shift;
    
    return unless($class->test_datatype($data));
    return unless(ref($data->{'data'}) eq 'IODEFDocumentType');
    
    my @ids;
    my $tbl = $class->table();
    foreach my $i (@{$data->{'data'}->get_Incident()}){

        my $impact = iodef_impacts_first($i);
        return unless($impact && $impact->get_content->get_content() eq 'malware');
        
        my $reporttime = $i->get_ReportTime();
        
        my $addresses = iodef_addresses($i);
        next if(@$addresses);
      
        my $ad = iodef_additional_data($i);
        return unless(@$ad);
        
        my $confidence = iodef_confidence($i);
        $confidence = @{$confidence}[0]->get_content();

        foreach my $a (@$ad){
            next unless($a->get_meaning() && lc($a->get_meaning()) =~ /^malware hash$/);
            next unless($a->get_content());
            my $hash = $a->get_content();
            if($class->test_feed($data)){
                if(my $t = return_table($hash)){
                    $class->table($t);
                }
                $class->SUPER::insert({
                    hash        => $hash,
                    uuid        => $i->get_IncidentID->get_content(),
                    guid        => iodef_guid($i) || $data->{'guid'},
                    confidence  => $confidence,
                    reporttime  => $reporttime,
                });
            }
            my $id = $class->insert_hash({ 
                uuid        => $data->{'uuid'}, 
                guid        => $data->{'guid'}, 
                confidence  => $confidence,
                reporttime  => $reporttime,
            },$hash);
            ## TODO: mem leak?
            push(@ids,@$id);
        }
    }
    $class->table($tbl);
    return(undef,\@ids);
}

sub return_table {
    my $hash = shift;
    foreach (@plugins){
        next unless($_->prepare($hash));
        return $_->table();
        last;
    }
}

1;